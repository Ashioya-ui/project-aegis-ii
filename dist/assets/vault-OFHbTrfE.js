const x=(e,t)=>t.some(n=>e instanceof n);let I,E;function C(){return I||(I=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function T(){return E||(E=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const A=new WeakMap,l=new WeakMap,M=new WeakMap,w=new WeakMap,D=new WeakMap;function P(e){const t=new Promise((n,o)=>{const c=()=>{e.removeEventListener("success",s),e.removeEventListener("error",r)},s=()=>{n(u(e.result)),c()},r=()=>{o(e.error),c()};e.addEventListener("success",s),e.addEventListener("error",r)});return t.then(n=>{n instanceof IDBCursor&&A.set(n,e)}).catch(()=>{}),D.set(t,e),t}function j(e){if(l.has(e))return;const t=new Promise((n,o)=>{const c=()=>{e.removeEventListener("complete",s),e.removeEventListener("error",r),e.removeEventListener("abort",r)},s=()=>{n(),c()},r=()=>{o(e.error||new DOMException("AbortError","AbortError")),c()};e.addEventListener("complete",s),e.addEventListener("error",r),e.addEventListener("abort",r)});l.set(e,t)}let h={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return l.get(e);if(t==="objectStoreNames")return e.objectStoreNames||M.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return u(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function k(e){h=e(h)}function v(e){return e===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(t,...n){const o=e.call(p(this),t,...n);return M.set(o,t.sort?t.sort():[t]),u(o)}:T().includes(e)?function(...t){return e.apply(p(this),t),u(A.get(this))}:function(...t){return u(e.apply(p(this),t))}}function V(e){return typeof e=="function"?v(e):(e instanceof IDBTransaction&&j(e),x(e,C())?new Proxy(e,h):e)}function u(e){if(e instanceof IDBRequest)return P(e);if(w.has(e))return w.get(e);const t=V(e);return t!==e&&(w.set(e,t),D.set(t,e)),t}const p=e=>D.get(e);function B(e,t,{blocked:n,upgrade:o,blocking:c,terminated:s}={}){const r=indexedDB.open(e,t),i=u(r);return o&&r.addEventListener("upgradeneeded",a=>{o(u(r.result),a.oldVersion,a.newVersion,u(r.transaction),a)}),n&&r.addEventListener("blocked",a=>n(a.oldVersion,a.newVersion,a)),i.then(a=>{s&&a.addEventListener("close",()=>s()),c&&a.addEventListener("versionchange",d=>c(d.oldVersion,d.newVersion,d))}).catch(()=>{}),i}const K=["get","getKey","getAll","getAllKeys","count"],N=["put","add","delete","clear"],m=new Map;function g(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(m.get(t))return m.get(t);const n=t.replace(/FromIndex$/,""),o=t!==n,c=N.includes(n);if(!(n in(o?IDBIndex:IDBObjectStore).prototype)||!(c||K.includes(n)))return;const s=async function(r,...i){const a=this.transaction(r,c?"readwrite":"readonly");let d=a.store;return o&&(d=d.index(i.shift())),(await Promise.all([d[n](...i),c&&a.done]))[0]};return m.set(t,s),s}k(e=>({...e,get:(t,n,o)=>g(t,n)||e.get(t,n,o),has:(t,n)=>!!g(t,n)||e.has(t,n)}));const S="AegisVault",f="secure_logs",y="aegis_master_key";async function L(){const e=await chrome.storage.local.get(y);if(e[y])return window.crypto.subtle.importKey("jwk",e[y],{name:"AES-GCM"},!0,["encrypt","decrypt"]);{const t=await window.crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),n=await window.crypto.subtle.exportKey("jwk",t);return await chrome.storage.local.set({[y]:n}),t}}async function O(e,t,n){const o=await L(),c=window.crypto.getRandomValues(new Uint8Array(12)),s=new TextEncoder().encode(e),r=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:c},o,s),i={id:crypto.randomUUID(),tabId:n,timestamp:Date.now(),url:t,iv:Array.from(c),data:Array.from(new Uint8Array(r))};await(await B(S,1,{upgrade(d){if(!d.objectStoreNames.contains(f)){const b=d.createObjectStore(f,{keyPath:"id"});b.createIndex("tabId","tabId"),b.createIndex("timestamp","timestamp")}}})).add(f,i),console.log(`[Aegis] Encrypted packet stored: ${i.id}`)}async function R(){const t=await(await B(S,1)).getAllFromIndex(f,"timestamp"),n=await L(),o=new TextDecoder;return(await Promise.all(t.map(async s=>{try{const r=new Uint8Array(s.iv),i=new Uint8Array(s.data),a=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:r},n,i);return{...s,text:o.decode(a),status:"verified"}}catch{return{...s,text:"[[DECRYPTION FAILED]]",status:"corrupted"}}}))).reverse()}export{O as e,R as f};
