const h=(e,t)=>t.some(n=>e instanceof n);let g,A;function T(){return g||(g=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function k(){return A||(A=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const I=new WeakMap,m=new WeakMap,w=new WeakMap;function j(e){const t=new Promise((n,r)=>{const c=()=>{e.removeEventListener("success",s),e.removeEventListener("error",o)},s=()=>{n(u(e.result)),c()},o=()=>{r(e.error),c()};e.addEventListener("success",s),e.addEventListener("error",o)});return w.set(t,e),t}function O(e){if(I.has(e))return;const t=new Promise((n,r)=>{const c=()=>{e.removeEventListener("complete",s),e.removeEventListener("error",o),e.removeEventListener("abort",o)},s=()=>{n(),c()},o=()=>{r(e.error||new DOMException("AbortError","AbortError")),c()};e.addEventListener("complete",s),e.addEventListener("error",o),e.addEventListener("abort",o)});I.set(e,t)}let p={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return I.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return u(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function P(e){p=e(p)}function K(e){return k().includes(e)?function(...t){return e.apply(D(this),t),u(this.request)}:function(...t){return u(e.apply(D(this),t))}}function V(e){return typeof e=="function"?K(e):(e instanceof IDBTransaction&&O(e),h(e,T())?new Proxy(e,p):e)}function u(e){if(e instanceof IDBRequest)return j(e);if(m.has(e))return m.get(e);const t=V(e);return t!==e&&(m.set(e,t),w.set(t,e)),t}const D=e=>w.get(e);function C(e,t,{blocked:n,upgrade:r,blocking:c,terminated:s}={}){const o=indexedDB.open(e,t),a=u(o);return r&&o.addEventListener("upgradeneeded",i=>{r(u(o.result),i.oldVersion,i.newVersion,u(o.transaction),i)}),n&&o.addEventListener("blocked",i=>n(i.oldVersion,i.newVersion,i)),a.then(i=>{s&&i.addEventListener("close",()=>s()),c&&i.addEventListener("versionchange",d=>c(d.oldVersion,d.newVersion,d))}).catch(()=>{}),a}const F=["get","getKey","getAll","getAllKeys","count"],N=["put","add","delete","clear"],l=new Map;function B(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(l.get(t))return l.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,c=N.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!(c||F.includes(n)))return;const s=async function(o,...a){const i=this.transaction(o,c?"readwrite":"readonly");let d=i.store;return r&&(d=d.index(a.shift())),(await Promise.all([d[n](...a),c&&i.done]))[0]};return l.set(t,s),s}P(e=>({...e,get:(t,n,r)=>B(t,n)||e.get(t,n,r),has:(t,n)=>!!B(t,n)||e.has(t,n)}));const R=["continue","continuePrimaryKey","advance"],M={},E=new WeakMap,L=new WeakMap,U={get(e,t){if(!R.includes(t))return e[t];let n=M[t];return n||(n=M[t]=function(...r){E.set(this,L.get(this)[t](...r))}),n}};async function*W(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const n=new Proxy(t,U);for(L.set(n,t),w.set(n,D(t));t;)yield n,t=await(E.get(n)||t.continue()),E.delete(n)}function x(e,t){return t===Symbol.asyncIterator&&h(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&h(e,[IDBIndex,IDBObjectStore])}P(e=>({...e,get(t,n,r){return x(t,n)?W:e.get(t,n,r)},has(t,n){return x(t,n)||e.has(t,n)}}));const S="AegisVault",f="secure_logs",y="aegis_master_key";async function v(){if(typeof chrome>"u"||!chrome.storage)return null;const e=await chrome.storage.local.get(y);if(e[y])return window.crypto.subtle.importKey("jwk",e[y],{name:"AES-GCM"},!0,["encrypt","decrypt"]);{const t=await window.crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),n=await window.crypto.subtle.exportKey("jwk",t);return await chrome.storage.local.set({[y]:n}),t}}async function _(e,t,n){try{const r=await v();if(!r)throw new Error("Key generation failed");const c=window.crypto.getRandomValues(new Uint8Array(12)),s=new TextEncoder().encode(e),o=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:c},r,s),a={id:crypto.randomUUID(),tabId:n,timestamp:Date.now(),url:t,iv:Array.from(c),data:Array.from(new Uint8Array(o))};await(await C(S,1,{upgrade(d){if(!d.objectStoreNames.contains(f)){const b=d.createObjectStore(f,{keyPath:"id"});b.createIndex("tabId","tabId"),b.createIndex("timestamp","timestamp")}}})).add(f,a),console.log(`[Aegis] Encrypted packet stored: ${a.id}`)}catch(r){console.error("[Aegis] Encryption Error:",r)}}async function G(){const t=await(await C(S,1)).getAllFromIndex(f,"timestamp"),n=await v(),r=new TextDecoder;return(await Promise.all(t.map(async s=>{try{const o=new Uint8Array(s.iv),a=new Uint8Array(s.data),i=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:o},n,a);return{...s,text:r.decode(i),status:"verified"}}catch{return{...s,text:"[[DECRYPTION FAILED]]",status:"corrupted"}}}))).reverse()}export{_ as e,G as f};
